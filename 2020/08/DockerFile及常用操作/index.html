<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>DockerFile及常用操作 | Outsrkem</title><meta name="generator" content="hexo-theme-ayer"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" href="/dist/main.css"><link rel="stylesheet" href="/css/fonts/remixicon.css"><link rel="stylesheet" href="/css/custom.css"><script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"><script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script><script src="https://cdn.staticfile.org/mermaid/8.14.0/mermaid.min.js"></script><style>.swal2-styled.swal2-confirm{font-size:1.6rem}</style></head></html><body><div id="app"><main class="content on"><section class="outer"><article id="post-DockerFile及常用操作" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal><div class="article-inner"><header class="article-header"><h1 class="article-title sea-center" style="border-left:0" itemprop="name"> DockerFile及常用操作</h1></header><div class="article-meta"> <a href="/2020/08/DockerFile%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/index.html" class="article-date"><time datetime="2020-08-14T12:44:03.000Z" itemprop="datePublished">2020-08-14 20:44:03 +08:00</time></a><div class="article-category"> <a class="article-category-link" href="/categories/%E6%9C%8D%E5%8A%A1/">服务</a> / <a class="article-category-link" href="/categories/%E6%9C%8D%E5%8A%A1/Docker/">Docker</a></div><div class="word_count"><span class="post-time"><span class="post-meta-item-icon"><i class="ri-quill-pen-line"></i> <span class="post-meta-item-text">字数统计:</span> <span class="post-count">6.7k</span></span></span> <span class="post-time">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="ri-book-open-line"></i> <span class="post-meta-item-text">阅读时长≈</span> <span class="post-count">27 分钟</span></span></span></div></div><div class="tocbot"></div><div class="article-entry" itemprop="articleBody"><h2 id="dockerfile及常用操作">DockerFile及常用操作</h2><h3 id="一般性的指南和建议">一般性的指南和建议</h3><h6 id="容器应该是短暂的">容器应该是短暂的</h6><p>通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。</p><h6 id="使用-dockerignore 文件">使用 .dockerignore 文件</h6><p>使用 Dockerfile 构建镜像时最好是将 Dockerfile 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 .dockerignore 文件来指定要忽略的文件和目录。.dockerignore 文件的排除模式语法和 Git 的 .gitignore 文件相似。</p><h6 id="使用多阶段构建">使用多阶段构建</h6><p>在 Docker 17.05 以上版本中，你可以使用 多阶段构建 来减少所构建镜像的大小。 避免安装不必要的包</p><h6 id="避免安装不必要的包">避免安装不必要的包</h6><p>为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器</p><h6 id="一个容器只运行一个进程">一个容器只运行一个进程</h6><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。如果容器互相依赖，你可以使用 Docker 自定义网络 来把这些容器连接起来。</p><h6 id="镜像层数尽可能少">镜像层数尽可能少</h6><p>你需要在 Dockerfile 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p><h6 id="将多行参数排序">将多行参数排序</h6><p>将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 PRs 阅读和审查。建议在反斜杠符号 \ 之前添加一个空格，以增加可读性。<br> 下面是来自 buildpack-deps 镜像的例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">bzr \</span></span><br><span class="line"><span class="language-bash">cvs \</span></span><br><span class="line"><span class="language-bash">git \</span></span><br><span class="line"><span class="language-bash">mercurial \</span></span><br><span class="line"><span class="language-bash">subversion</span></span><br></pre></td></tr></table></figure><h6 id="构建缓存">构建缓存</h6><p>在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 <code>--no-cache=true</code> 选项。</p><p>但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下：<br> 从一个基础镜像开始（<code>FROM</code> 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。</p><p>在大多数情况下，只需要简单地对比 Dockerfile 中的指令和子镜像。然而，有些指令需要更多的检查和解释。<br> 对于 <code>ADD</code> 和 <code>COPY</code> 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。</p><p>除了 <code>ADD</code> 和 <code>COPY</code> 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 <code>RUN apt-get -y update</code> 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。<br> 一旦缓存失效，所有后续的 Dockerfile 指令都将产生新的镜像，缓存不会被使用。</p><h3 id="dockerfile-指令">Dockerfile 指令</h3><h6 id="下面针对-dockerfile 中各种指令的最佳编写方式给出建议。">下面针对 Dockerfile 中各种指令的最佳编写方式给出建议。</h6><blockquote><p><code>FROM</code></p></blockquote><p>尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 Alpine 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 MB），但它仍然是一个完整的发行版。</p><blockquote><p><code>LABEL</code></p></blockquote><p>你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 LABEL 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。# 开头的行是注释内容。<br> 注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。<br> 关于标签可以接受的键值对，参考 Understanding object labels。关于查询标签信息，参考 Managing labels on objects。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set one or more individual labels</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.version.is-production=<span class="string">&quot;&quot;</span></span></span><br></pre></td></tr></table></figure><p>一个镜像可以包含多个标签，但建议将多个标签放入到一个 LABEL 指令中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="language-bash">com.example.is-beta= \</span></span><br><span class="line"><span class="language-bash">com.example.is-production=<span class="string">&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span> \</span></span><br><span class="line"><span class="language-bash">com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br></pre></td></tr></table></figure><blockquote><p><code>RUN</code></p></blockquote><p>为了保持 Dockerfile 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 RUN 指令用反斜杠 \ 分割成多行。<br> RUN 指令最常见的用法是安装包用的 <code>apt-get</code>。因为 <code>RUN apt-get</code> 指令会安装包，所以有几个问题需要注意。<br> 不要使用 <code>RUN apt-get upgrade</code> 或 <code>dist-upgrade</code>，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 foo，需要升级，使用 <code>apt-get install -y foo</code> 就行，该指令会自动升级 foo 包。</p><p>永远将 RUN apt-get update 和 apt-get install 组合成一条 RUN 声明，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">package-bar \</span></span><br><span class="line"><span class="language-bash">package-baz \</span></span><br><span class="line"><span class="language-bash">package-foo</span></span><br></pre></td></tr></table></figure><p>将 <code>apt-get update</code> 放在一条单独的 RUN 声明中会导致缓存问题以及后续的<code>apt-get install</code>失败。比如，假设你有一个 Dockerfile 文件：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl</span></span><br></pre></td></tr></table></figure><p>构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 <code>apt-get install</code> 添加了一个包：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get install -y curl nginx</span></span><br></pre></td></tr></table></figure><p>Docker 发现修改后的 RUN apt-get update 指令和之前的完全一样。所以，apt-get update 不会执行，而是使用之前的缓存镜像。因为 apt-get update 没有运行，后面的 apt-get install 可能安装的是过时的 curl 和 nginx 版本。</p><p>使用 RUN apt-get update &amp;&amp; apt-get install -y 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 cache busting。你也可以显示指定一个包的版本号来达到 cache-busting，这就是所谓的固定版本，例如：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    package-bar \</span></span><br><span class="line"><span class="language-bash">    package-baz \</span></span><br><span class="line"><span class="language-bash">    package-foo=1.3.*</span></span><br></pre></td></tr></table></figure><p>固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。下面是一个 RUN 指令的示例模板，展示了所有关于 apt-get 的建议。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    aufs-tools \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    dpkg-sig \</span></span><br><span class="line"><span class="language-bash">    libcap-dev \</span></span><br><span class="line"><span class="language-bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="language-bash">    mercurial \</span></span><br><span class="line"><span class="language-bash">    reprepro \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="language-bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure><p>其中 s3cmd 指令指定了一个版本号 1.1.*。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 apt-get udpate 缓存失效并确保安装的是新版本。<br> 另外，清理掉 apt 缓存 var/lib/apt/lists 可以减小镜像大小。因为 RUN 指令的开头为 apt-get udpate，包缓存总是会在 apt-get install 之前刷新。<br> 注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。</p><blockquote><p>CMD</p></blockquote><p>CMD 指令用于执行目标镜像中包含的软件，可以包含参数。CMD 大多数情况下都应该以 <code>CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...]</code> 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 Apache)，你可能会执行类似于 <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code> 形式的命令。我们建议任何服务镜像都使用这种形式的命令。<br> 多数情况下，CMD 都需要一个交互式的 shell (bash, Python, perl 等)，例如 <code>CMD [&quot;perl&quot;, &quot;-de0&quot;]，或者 CMD [&quot;PHP&quot;, &quot;-a&quot;]</code>。使用这种形式意味着，当你执行类似 docker run -it python 时，你会进入一个准备好的 shell 中。CMD 应该在极少的情况下才能以 <code>CMD [&quot;param&quot;, &quot;param&quot;]</code> 的形式与 <code>ENTRYPOINT</code> 协同使用，除非你和你的镜像使用者都对 <code>ENTRYPOINT</code> 的工作方式十分熟悉。</p><blockquote><p>EXPOSE</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 Apache web 服务的镜像应该使用 <span class="keyword">EXPOSE</span> <span class="number">80</span>，而提供 MongoDB 服务的镜像使用 <span class="keyword">EXPOSE</span> <span class="number">27017</span>。</span><br><span class="line">对于外部访问，用户可以在执行 docker <span class="keyword">run</span><span class="language-bash"> 时使用一个标志来指示如何将指定的端口映射到所选择的端口。</span></span><br><span class="line"><span class="keyword">ENV</span></span><br><span class="line">为了方便新程序运行，你可以使用 <span class="keyword">ENV</span> 来为容器中安装的程序更新 PATH 环境变量。例如使用 <span class="keyword">ENV</span> PATH /usr/local/nginx/bin:$PATH 来确保 <span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>] 能正确运行。</span></span><br><span class="line"><span class="keyword">ENV</span> 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 PGDATA。</span><br><span class="line">最后，<span class="keyword">ENV</span> 也能用于设置常见的版本号，比如下面的示例：</span><br><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br><span class="line">类似于程序中的常量，这种方法可以让你只需改变 <span class="keyword">ENV</span> 指令来自动的改变容器中的软件版本。</span><br><span class="line">两种写法：</span><br><span class="line"><span class="keyword">ENV</span> nane=bijianyong xu=hahuaxuanyan age=<span class="number">123</span></span><br><span class="line">注意，写一行对PATH变量不生效（同时执行时$NGINX_HOME为空，所以导致变量无效）</span><br><span class="line"><span class="keyword">ENV</span> NGINX_HOME /usr/local/nginx</span><br><span class="line"><span class="keyword">ENV</span> PATH $NGINX_HOME/sbin:$PATH</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> 和 COPY</span></span><br><span class="line">虽然 <span class="keyword">ADD</span><span class="language-bash"> 和 COPY 功能类似，但一般优先使用 COPY。因为它比 ADD 更透明。COPY 只支持简单将本地文件拷贝到容器中，而 ADD 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，ADD 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 ADD rootfs.tar.xz。</span></span><br><span class="line">如果你的 Dockerfile 有多个步骤需要使用上下文中不同的文件。单独 <span class="keyword">COPY</span><span class="language-bash"> 每个文件，而不是一次性的 COPY 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如：</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt /tmp/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --requirement /tmp/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . /tmp/</span></span><br><span class="line">如果将 <span class="keyword">COPY</span><span class="language-bash"> . /tmp/ 放置在 RUN 指令之前，只要 . 目录中任何一个文件变化，都会导致后续指令的缓存失效。</span></span><br><span class="line">为了让镜像尽量小，最好不要使用 <span class="keyword">ADD</span><span class="language-bash"> 指令从远程 URL 获取包，而是使用 curl 和 wget。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法：</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> http://example.com/big.tar.xz /usr/src/things/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> make -C /usr/src/things all</span></span><br><span class="line">而是应该使用下面这种方法：</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="language-bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/things all</span></span><br><span class="line">上面使用的管道操作，所以没有中间文件需要删除。</span><br><span class="line">对于其他不需要 <span class="keyword">ADD</span><span class="language-bash"> 的自动提取功能的文件或目录，你应该使用 COPY。</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">ENTRYPOINT 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 CMD 提供默认选项）。</span></span><br><span class="line">例如，下面的示例镜像提供了命令行工具 s3cmd:</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;s3cmd&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br><span class="line">现在直接运行该镜像创建的容器会显示命令帮助：</span><br><span class="line">$ docker <span class="keyword">run</span><span class="language-bash"> s3cmd</span></span><br><span class="line">或者提供正确的参数来执行某个命令：</span><br><span class="line">$ docker <span class="keyword">run</span><span class="language-bash"> s3cmd <span class="built_in">ls</span> s3://mybucket</span></span><br><span class="line">这样镜像名可以当成命令行的参考。</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。</span></span><br><span class="line">例如，Postgres 官方镜像使用下面的脚本作为 <span class="keyword">ENTRYPOINT</span><span class="language-bash">：</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">if [ <span class="string">&quot;$1&quot;</span> = <span class="string">&#x27;postgres&#x27;</span> ]; then</span><br><span class="line">    chown -R postgres <span class="string">&quot;$PGDATA&quot;</span></span><br><span class="line">    if [ -z <span class="string">&quot;$(ls -A &quot;</span>$PGDATA<span class="string">&quot;)&quot;</span> ]; then</span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    fi</span><br><span class="line">    exec gosu postgres <span class="string">&quot;$@&quot;</span></span><br><span class="line">fi</span><br><span class="line">exec <span class="string">&quot;$@&quot;</span></span><br><span class="line">注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 <span class="number">1</span> 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。</span><br><span class="line">该辅助脚本被拷贝到容器，并在容器启动时通过 <span class="keyword">ENTRYPOINT</span><span class="language-bash"> 执行：</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-entrypoint.sh /</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/docker-entrypoint.sh&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;mysqld&quot;</span>]</span></span><br><span class="line">该脚本可以让用户用几种不同的方式和 Postgres 交互。</span><br><span class="line">你可以很简单地启动 Postgres：</span><br><span class="line">$ docker <span class="keyword">run</span><span class="language-bash"> postgres</span></span><br><span class="line">也可以执行 Postgres 并传递参数：</span><br><span class="line">$ docker <span class="keyword">run</span><span class="language-bash"> postgres postgres --<span class="built_in">help</span></span></span><br><span class="line">最后，你还可以启动另外一个完全不同的工具，比如 Bash：</span><br><span class="line">$ docker <span class="keyword">run</span><span class="language-bash"> --<span class="built_in">rm</span> -it postgres bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">VOLUME 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 VOLUME 来管理镜像中的可变部分和用户可以改变的部分。</span></span><br><span class="line"><span class="keyword">USER</span></span><br><span class="line">如果某个服务不需要特权执行，建议使用 <span class="keyword">USER</span> 指令切换到非 root 用户。先在 Dockerfile 中使用类似 <span class="keyword">RUN</span><span class="language-bash"> groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 的指令创建用户和用户组。</span></span><br><span class="line">注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。</span><br><span class="line">你应该避免使用 sudo，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 sudo 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 gosu。</span><br><span class="line">最后，为了减少层数和复杂度，避免频繁地使用 <span class="keyword">USER</span> 来回切换用户。</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">为了清晰性和可靠性，你应该总是在 WORKDIR 中使用绝对路径。另外，你应该使用 WORKDIR 来替代类似于 RUN <span class="built_in">cd</span> ... &amp;&amp; do-something 的指令，后者难以阅读、排错和维护。</span></span><br><span class="line">官方仓库示例</span><br><span class="line">这些官方仓库的 Dockerfile 都是参考典范：https://github.com/docker-library/docs</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> </span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</span></span><br><span class="line">在没有 <span class="keyword">HEALTHCHECK</span><span class="language-bash"> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</span></span><br><span class="line">而自 <span class="number">1.12</span> 之后，Docker 提供了 <span class="keyword">HEALTHCHECK</span><span class="language-bash"> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</span></span><br><span class="line">当在一个镜像指定了 <span class="keyword">HEALTHCHECK</span><span class="language-bash"> 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> 支持下列选项：</span></span><br><span class="line">--interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 <span class="number">30</span> 秒；</span><br><span class="line">--timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 <span class="number">30</span> 秒；</span><br><span class="line">--retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 <span class="number">3</span> 次。</span><br><span class="line">和 <span class="keyword">CMD</span><span class="language-bash">, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</span></span><br><span class="line">在 <span class="keyword">HEALTHCHECK</span><span class="language-bash"> [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 <span class="built_in">exec</span> 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。</span></span><br><span class="line">假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 <span class="keyword">HEALTHCHECK</span><span class="language-bash"> 可以这么写：</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5s --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -fs http://localhost/ || <span class="built_in">exit</span> 1</span></span><br><span class="line">这里我们设置了每 <span class="number">5</span> 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 <span class="number">3</span> 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit <span class="number">1</span> 作为健康检查命令。</span><br><span class="line">使用 docker build 来构建这个镜像：</span><br><span class="line">$ docker build -t myweb:v1 .</span><br><span class="line">构建好了后，我们启动一个容器：</span><br><span class="line">$ docker <span class="keyword">run</span><span class="language-bash"> -d --name web -p 80:80 myweb:v1</span></span><br><span class="line">当运行该镜像后，可以通过 docker container ls 看到最初的状态为 (health: starting)：</span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line"><span class="number">03</span>e28eb00bd0        myweb:v1            <span class="string">&quot;nginx -g &#x27;daemon off&quot;</span>   <span class="number">3</span> seconds ago       Up <span class="number">2</span> seconds (health: starting)   <span class="number">80</span>/tcp, <span class="number">443</span>/tcp     web</span><br><span class="line">在等待几秒钟后，再次 docker container ls，就会看到健康状态变化为了 (healthy)：</span><br><span class="line">$ docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES</span><br><span class="line"><span class="number">03</span>e28eb00bd0        myweb:v1            <span class="string">&quot;nginx -g &#x27;daemon off&quot;</span>   <span class="number">18</span> seconds ago      Up <span class="number">16</span> seconds (healthy)   <span class="number">80</span>/tcp, <span class="number">443</span>/tcp     web</span><br><span class="line">如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。</span><br><span class="line">为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。</span><br><span class="line">$ docker inspect --format <span class="string">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> web | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;FailingStreak&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;Log&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;End&quot;</span>: <span class="string">&quot;2016-11-25T14:35:37.940957051Z&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ExitCode&quot;</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="string">&quot;Output&quot;</span>: <span class="string">&quot;&lt;!DOCTYPE h。。。。。。。,</span></span><br><span class="line"><span class="string">            &quot;</span>Start<span class="string">&quot;: &quot;</span><span class="number">2016</span>-<span class="number">11</span>-<span class="number">25</span>T14:<span class="number">35</span>:<span class="number">37.780192565</span>Z<span class="string">&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ],</span></span><br><span class="line"><span class="string">    &quot;</span>Status<span class="string">&quot;: &quot;</span>healthy<span class="string">&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ARG</span></span><br><span class="line"><span class="string">ARG 可以在构建镜像的时候传递参数</span></span><br><span class="line"><span class="string">FROM hub.c.163.com/library/centos:7.4.1708</span></span><br><span class="line"><span class="string">MAINTAINER bijianyong &lt;bijianyong@126.com&gt;</span></span><br><span class="line"><span class="string">ARG version_tag</span></span><br><span class="line"><span class="string">LABEL version=$&#123;version_tag:-0.0.1&#125; author=&quot;</span>bijianyong &lt;bijianyong@<span class="number">126</span>.com&gt;<span class="string">&quot;</span></span><br><span class="line"><span class="string">WORKDIR /root</span></span><br><span class="line"><span class="string">RUN echo $&#123;version_tag:-0.0.1&#125; &gt; ./version</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">此时创建镜像version_tag会被替换成19.12.19</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker build --build-arg version_tag=&quot;</span><span class="number">19.12</span>.<span class="number">19</span><span class="string">&quot; -t test: 19.12.19 .  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">获取镜像或容器元数据</span></span><br><span class="line"><span class="string">docker inspect -f &quot;</span>&#123;&#123;json .Config.Labels &#125;&#125;<span class="string">&quot; $IMAGE | python -m json.tool</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker-compose</span></span><br><span class="line"><span class="string">version: &#x27;3&#x27;</span></span><br><span class="line"><span class="string">  services:</span></span><br><span class="line"><span class="string">    web:</span></span><br><span class="line"><span class="string">      image: $&#123;IMAGETAG&#125;</span></span><br><span class="line"><span class="string">      ports:</span></span><br><span class="line"><span class="string">       - &quot;</span><span class="number">5000</span>:<span class="number">5000</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">    redis:</span></span><br><span class="line"><span class="string">      image: &quot;</span>redis:alpine<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用文件为容器设置多个环境变量</span></span><br><span class="line"><span class="string">如果觉得通过 environment 为容器设置环境变量不够过瘾，我们还可以像 docker -run 的 --env-file 参数一样通过文件为容器设置环境变量：</span></span><br><span class="line"><span class="string">web:</span></span><br><span class="line"><span class="string">  env_file:</span></span><br><span class="line"><span class="string">- web-variables.env</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意，web-variables.env 文件的路径是相对于 docker-compose.yml 文件的相对路径。上面的代码效果与下面的代码相同：</span></span><br><span class="line"><span class="string">$ docker run --env-file=web-variables.env</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">web-variables.env 文件中可以定义一个或多个环境变量：</span></span><br><span class="line"><span class="string"># define web container env</span></span><br><span class="line"><span class="string">APPNAME=helloworld</span></span><br><span class="line"><span class="string">AUTHOR=Nick Li</span></span><br><span class="line"><span class="string">VERSION=1.0</span></span><br><span class="line"><span class="string">检查下结果：</span></span><br><span class="line"><span class="string">compose 把 env_file 的设置翻译成了 environment！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.env 文件</span></span><br><span class="line"><span class="string">当我们在 docker-compose.yml 文件中引用了大量的环境变量时，对每个环境变量都设置默认值将是繁琐的，并且也会影响 docker-compose.yml 简洁程度。此时我们可以通过 .env 文件来为 docker-compose.yml 文件引用的所有环境变量设置默认值！</span></span><br><span class="line"><span class="string">修改 docker-compose.yml 文件的内容如下：</span></span><br><span class="line"><span class="string">version: &#x27;3&#x27;</span></span><br><span class="line"><span class="string">services:</span></span><br><span class="line"><span class="string">  web:</span></span><br><span class="line"><span class="string">    image: $&#123;IMAGETAG&#125;                 </span></span><br><span class="line"><span class="string">    environment:</span></span><br><span class="line"><span class="string">      APPNAME: $&#123;APPNAME&#125;</span></span><br><span class="line"><span class="string">      AUTHOR:$&#123;AUTHOR&#125;</span></span><br><span class="line"><span class="string">      VERSION:$&#123;VERSION&#125;</span></span><br><span class="line"><span class="string">    ports:</span></span><br><span class="line"><span class="string">     - &quot;</span><span class="number">5000</span>:<span class="number">5000</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">  redis:</span></span><br><span class="line"><span class="string">    image: &quot;</span>redis:alpine<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">然后在相同的目录下创建 .env 文件，编辑其内容如下：</span></span><br><span class="line"><span class="string"># define env var default value.</span></span><br><span class="line"><span class="string">IMAGETAG=defaultwebimage</span></span><br><span class="line"><span class="string">APPNAME=default app name</span></span><br><span class="line"><span class="string">AUTHOR=default author name</span></span><br><span class="line"><span class="string">VERSION=default version is 1.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker-compose config 命令检查下结果，此时所有的环境变量都显示为 .env 文件中定义的默认值：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Docker容器的重启策略是面向生产环境的一个启动策略，在开发过程中可以忽略该策略。</span></span><br><span class="line"><span class="string">Docker容器的重启都是由Docker守护进程完成的，因此与守护进程息息相关。</span></span><br><span class="line"><span class="string">Docker容器的重启策略如下：</span></span><br><span class="line"><span class="string">•	no，默认策略，在容器退出时不重启容器</span></span><br><span class="line"><span class="string">•	on-failure，在容器非正常退出时（退出状态非0），才会重启容器</span></span><br><span class="line"><span class="string">o	on-failure:3，在容器非正常退出时重启容器，最多重启3次</span></span><br><span class="line"><span class="string">•	always，在容器退出时总是重启容器</span></span><br><span class="line"><span class="string">•	unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</span></span><br><span class="line"><span class="string">docker run --restart=always nginx</span></span><br><span class="line"><span class="string">docker run --restart=on-failure nginx</span></span><br><span class="line"><span class="string">docker run --restart=on-failure:10 nginx</span></span><br><span class="line"><span class="string">在线更新重启策略</span></span><br><span class="line"><span class="string">docker update --restart=always container</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看当前策略</span></span><br><span class="line"><span class="string">docker inspect -f &quot;</span>&#123;&#123; .HostConfig.RestartPolicy.Name &#125;&#125;<span class="string">&quot; container</span></span><br><span class="line"><span class="string">查看容器重启次数</span></span><br><span class="line"><span class="string">docker inspect -f &quot;</span>&#123;&#123; .RestartCount &#125;&#125;<span class="string">&quot; nginx</span></span><br><span class="line"><span class="string">查看容器最后一次的启动时间</span></span><br><span class="line"><span class="string">docker inspect -f &quot;</span>&#123;&#123; .State.StartedAt &#125;&#125;<span class="string">&quot; nginx</span></span><br><span class="line"><span class="string">Docker容器的退出状态码</span></span><br><span class="line"><span class="string">•	0，表示正常退出</span></span><br><span class="line"><span class="string">•	!0，表示异常退出（退出状态码采用chroot标准）</span></span><br><span class="line"><span class="string">o	125，Docker守护进程本身的错误</span></span><br><span class="line"><span class="string">o	126，容器启动后，要执行的默认命令无法调用</span></span><br><span class="line"><span class="string">o	127，容器启动后，要执行的默认命令不存在</span></span><br><span class="line"><span class="string">•	其他命令状态码，容器启动后正常执行命令，退出命令时该命令的返回状态码作为容器的退出状态码</span></span><br><span class="line"><span class="string">参</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">一.<span class="number">1</span>	多阶段构建</span><br><span class="line">一.<span class="number">1.1</span>	之前的做法</span><br><span class="line">在 Docker <span class="number">17.05</span> 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</span><br><span class="line">一.<span class="number">1.1</span>.<span class="number">1</span>	全部放入一个 Dockerfile</span><br><span class="line">一种方式是将所有的构建过程编包含在一个 Dockerfile 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</span><br><span class="line">•	Dockerfile 特别长，可维护性降低</span><br><span class="line">•	镜像层次多，镜像体积较大，部署时间变长</span><br><span class="line">•	源代码存在泄露的风险</span><br><span class="line">例如</span><br><span class="line">编写 app.go 文件，该程序输出 Hello World!</span><br><span class="line">package main  </span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line"></span><br><span class="line">func main()&#123;  </span><br><span class="line">    fmt.Printf(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">编写 Dockerfile.one 文件</span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">cp</span> /go/src/github.com/go/helloworld/app /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br><span class="line">构建镜像</span><br><span class="line">$ docker build -t go/helloworld:<span class="number">1</span> -f Dockerfile.one .</span><br><span class="line">一.<span class="number">1.1</span>.<span class="number">2</span>	分散到多个 Dockerfile</span><br><span class="line">另一种方式，就是我们事先在一个 Dockerfile 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 Dockerfile 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</span><br><span class="line">例如</span><br><span class="line">编写 Dockerfile.build 文件</span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line">编写 Dockerfile.copy 文件</span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br><span class="line">新建 build.sh</span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line">echo Building go/helloworld:build</span><br><span class="line"></span><br><span class="line">docker build -t go/helloworld:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract go/helloworld:build</span><br><span class="line">docker cp extract:/go/src/github.com/go/helloworld/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line">echo Building go/helloworld:<span class="number">2</span></span><br><span class="line"></span><br><span class="line">docker build --no-cache -t go/helloworld:<span class="number">2</span> . -f Dockerfile.copy</span><br><span class="line">rm ./app</span><br><span class="line">现在运行脚本即可构建镜像</span><br><span class="line">$ chmod +x build.sh</span><br><span class="line"></span><br><span class="line">$ ./build.sh</span><br><span class="line">对比两种方式生成的镜像大小</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG    IMAGE ID        CREATED         SIZE</span><br><span class="line">go/helloworld   <span class="number">2</span>      f7cf3465432c    <span class="number">22</span> seconds ago  <span class="number">6.47</span>MB</span><br><span class="line">go/helloworld   <span class="number">1</span>      f55d3e16affc    <span class="number">2</span> minutes ago   <span class="number">295</span>MB</span><br><span class="line">一.<span class="number">1.2</span>	使用多阶段构建</span><br><span class="line">为解决以上问题，Docker v17.<span class="number">05</span> 开始支持多阶段构建 (multistage builds)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 Dockerfile：</span><br><span class="line">例如</span><br><span class="line">编写 Dockerfile 文件</span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/go/helloworld/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v github.com/go-sql-driver/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest as prod</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]  </span></span><br><span class="line">构建镜像</span><br><span class="line">$ docker build -t go/helloworld:<span class="number">3</span> .</span><br><span class="line">对比三个镜像大小</span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line">REPOSITORY        TAG   IMAGE ID         CREATED            SIZE</span><br><span class="line">go/helloworld     <span class="number">3</span>     d6911ed9c846     <span class="number">7</span> seconds ago      <span class="number">6.47</span>MB</span><br><span class="line">go/helloworld     <span class="number">2</span>     f7cf3465432c     <span class="number">22</span> seconds ago     <span class="number">6.47</span>MB</span><br><span class="line">go/helloworld     <span class="number">1</span>     f55d3e16affc     <span class="number">2</span> minutes ago      <span class="number">295</span>MB</span><br><span class="line">很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</span><br><span class="line">一.<span class="number">1.2</span>.<span class="number">1</span>	只构建某一阶段的镜像</span><br><span class="line">我们可以使用 as 来为某一阶段命名，例如</span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>-alpine as builder</span><br><span class="line">例如当我们只想构建 builder 阶段的镜像时，我们可以在使用 docker build 命令时加上 --target 参数即可</span><br><span class="line">$ docker build --target builder -t username/imagename:tag .</span><br><span class="line">一.<span class="number">1.2</span>.<span class="number">2</span>	构建时从其他镜像复制文件</span><br><span class="line">上面例子中我们使用 <span class="keyword">COPY</span><span class="language-bash"> --from=0 /go/src/github.com/go/helloworld/app . 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</span></span><br><span class="line">$ <span class="keyword">COPY</span><span class="language-bash"> --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><div id="reword-out"><div id="reward-btn"> 打赏</div></div></div><div class="declare"><ul class="post-copyright"><li><i class="ri-copyright-line"></i> <strong>版权声明：</strong> 本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！</li></ul></div><footer class="article-footer"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/" rel="tag">Docker</a></li></ul></footer></div><nav class="article-nav"> <a href="/2020/09/iptables%E5%9F%BA%E7%A1%80%E8%A7%84%E5%88%99%E9%85%8D%E7%BD%AE/index.html" class="article-nav-link"><strong class="article-nav-caption">上一篇</strong><div class="article-nav-title"> iptables基础规则配置</div></a> <a href="/2020/07/iptables%E6%93%8D%E4%BD%9C/index.html" class="article-nav-link"><strong class="article-nav-caption">下一篇</strong><div class="article-nav-title">iptablse服务管理</div></a></nav><script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script><div id="twikoo" class="twikoo"></div><script>twikoo.init({envId:""})</script></article></section><footer class="footer"><div class="outer"><ul><li> Copyrights &copy; 2018-2024<i class="ri-heart-fill heart_icon"></i> Outsrkem</li></ul><ul><li></li></ul><ul><li><span><span><i class="ri-user-3-fill"></i> 访问人数:<span id="busuanzi_value_site_uv"></span></span> <span class="division">|</span><span><i class="ri-eye-fill"></i> 浏览次数:<span id="busuanzi_value_page_pv"></span></span></span></li></ul><ul></ul><ul></ul><ul><li><script type="text/javascript" src="https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914"></script></li></ul></div></footer></main><div class="float_btns"><div class="totop" id="totop"><i class="ri-arrow-up-line"></i></div><div class="todark" id="todark"><i class="ri-moon-line"></i></div></div><aside class="sidebar on"> <button class="navbar-toggle"></button><nav class="navbar"><div class="logo"> <a href="/"><img src="/images/ayer-side.svg" alt="Outsrkem"></a></div><ul class="nav nav-main"><li class="nav-item"> <a class="nav-item-link" href="/index.html">主页</a></li><li class="nav-item"> <a class="nav-item-link" href="/archives/index.html">归档</a></li><li class="nav-item"> <a class="nav-item-link" href="/categories/index.html">分类</a></li><li class="nav-item"> <a class="nav-item-link" href="/tags/index.html">标签</a></li><li class="nav-item"> <a class="nav-item-link" href="/friends/index.html">友链</a></li><li class="nav-item"> <a class="nav-item-link" href="/about/index.html">关于</a></li></ul></nav><nav class="navbar navbar-bottom"><ul class="nav"><li class="nav-item"><a class="nav-item-link nav-item-search" title="搜索"><i class="ri-search-line"></i></a></li></ul></nav><div class="search-form-wrap"><div class="local-search local-search-plugin"> <input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."><div id="local-search-result" class="local-search-result"></div></div></div></aside><div id="mask"></div> <div id="reward"><span class="close"><i class="ri-close-line"></i></span><p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p><div class="reward-box"><div class="reward-item"> <img class="reward-img" src="/images/alipay.jpg"> <span class="reward-type">支付宝</span></div><div class="reward-item"> <img class="reward-img" src="/images/wechat.jpg"> <span class="reward-type">微信</span></div></div></div><script src="/js/jquery-3.6.0.min.js"></script><script src="/js/lazyload.min.js"></script><script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"><script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script><script src="/dist/main.js"></script><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><div class="pswp__bg"></div><div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button class="pswp__button pswp__button--close" title="Close (Esc)"></button> <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button> <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button> <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button> <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css"><script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script><script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script><script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script><script src="/js/busuanzi-2.3.pure.min.js"></script><link rel="stylesheet" href="/css/clipboard.css"><script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script><script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script><script>window.mermaid&&mermaid.initialize({theme:"forest"})</script></div></body>